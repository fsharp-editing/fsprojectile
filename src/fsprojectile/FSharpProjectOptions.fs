namespace fsprojectile
(*
    This file holds a dummy shim to stand in for FSharpProjectOptions when building on netcore
    Once the FSharp.Compiler.Service becomes netcore compatible this file will be removed
*)

#if NETCORE
open System
open System.IO
open System.Text
open System.Collections.Generic

module ProjectOptionsShim =

    exception IllegalFileNameChar of string * char

    /// The set of characters which may not be used in a path.
    /// This is saved here because Path.GetInvalidPathChars() allocates and returns
    /// a new array each time it's called (by necessity, for security reasons).
    /// This is only used within `checkPathForIllegalChars`, and is only read from.
    let illegalPathChars =
        let chars = Path.GetInvalidPathChars ()
        chars


    type private PathState =
        | Legal
        | Illegal of path: string * illegalChar: char

    let private checkPathForIllegalChars =
        let cache = System.Collections.Concurrent.ConcurrentDictionary<string, PathState>()
        fun (path: string) ->
            match cache.TryGetValue path with
            | true, Legal -> ()
            | true, Illegal (path, c) -> raise(IllegalFileNameChar(path, c))
            | _ ->
                let len = path.Length
                for i = 0 to len - 1 do
                    let c = path.[i]

                    // Determine if this character is disallowed within a path by
                    // attempting to find it in the array of illegal path characters.
                    for badChar in illegalPathChars do
                        if c = badChar then
                            cache.[path] <- Illegal(path, c)
                            raise(IllegalFileNameChar(path, c))
                cache.[path] <- Legal


    let fileNameWithoutExtension s =
        checkPathForIllegalChars s
        Path.GetFileNameWithoutExtension s


    type TimeStampCache() =
        let cacheCreation = DateTime.Now
        let files = Dictionary<string,DateTime>()
        let projects = Dictionary<IProjectReference,DateTime>(HashIdentity.Reference)
        member x.CacheCreation = cacheCreation
        member x.Files = files
        member x.Projects = projects

    and IProjectReference =
        /// The name of the assembly file generated by the project
        abstract FileName : string
        /// Evaluate raw contents of the assembly file generated by the project
    //    abstract EvaluateRawContents : unit -> IRawFSharpAssemblyData option
        abstract EvaluateRawContents : unit -> string option
        /// Get the logical timestamp that would be the timestamp of the assembly file generated by the project
        abstract GetLogicalTimeStamp : TimeStampCache -> DateTime option

    [<Struct>]
    type range (pos:int,col:int) =
        member __.Pos = pos
        member __.Col = int


    type AssemblyReference =
        | AssemblyReference of range * string * IProjectReference option
        member x.Range = (let (AssemblyReference(m,_,_)) = x in m)
        member x.Text = (let (AssemblyReference(_,text,_)) = x in text)
        member x.ProjectReference = (let (AssemblyReference(_,_,contents)) = x in contents)
        member x.SimpleAssemblyNameIs(name) =
            (String.Compare(fileNameWithoutExtension x.Text, name, StringComparison.OrdinalIgnoreCase) = 0) ||
            (let text = x.Text.ToLowerInvariant()
             not (text.Contains "/") && not (text.Contains "\\") && not (text.Contains ".dll") && not (text.Contains ".exe") &&
               try let aname = System.Reflection.AssemblyName(x.Text) in aname.Name = name
               with _ -> false)
        override x.ToString() = sprintf "AssemblyReference(%s)" x.Text

    type UnresolvedAssemblyReference = UnresolvedAssemblyReference of string * AssemblyReference list

    type  UnresolvedReferencesSet = UnresolvedReferencesSet of UnresolvedAssemblyReference list

    type FSharpProjectOptions =
        {
          ProjectFileName: string
          ProjectFileNames: string[]
          OtherOptions: string[]
          ReferencedProjects: (string * FSharpProjectOptions)[]
          IsIncompleteTypeCheckEnvironment : bool
          UseScriptResolutionRules : bool
          LoadTime : System.DateTime
          UnresolvedReferences : UnresolvedReferencesSet option
        }
        member x.ProjectOptions = x.OtherOptions
        /// Whether the two parse options refer to the same project.
        static member AreSubsumable(options1,options2) =
            options1.ProjectFileName = options2.ProjectFileName

        /// Compare two options sets with respect to the parts of the options that are important to parsing.
        static member AreSameForParsing(options1,options2) =
            options1.ProjectFileName = options2.ProjectFileName &&
            options1.OtherOptions = options2.OtherOptions &&
            options1.UnresolvedReferences = options2.UnresolvedReferences

        /// Compare two options sets with respect to the parts of the options that are important to building.
        static member AreSameForChecking(options1,options2) =
            options1.ProjectFileName = options2.ProjectFileName &&
            options1.ProjectFileNames = options2.ProjectFileNames &&
            options1.OtherOptions = options2.OtherOptions &&
            options1.ReferencedProjects.Length = options2.ReferencedProjects.Length &&
            Array.forall2 (fun (n1,a) (n2,b) -> n1 = n2 && FSharpProjectOptions.AreSameForChecking(a,b)) options1.ReferencedProjects options2.ReferencedProjects &&
            options1.LoadTime = options2.LoadTime

        /// Compute the project directory.
        member po.ProjectDirectory = System.IO.Path.GetDirectoryName(po.ProjectFileName)
        override this.ToString() =
            let files =
                let sb = new StringBuilder()
                this.ProjectFileNames |> Array.iter (fun file -> sb.AppendFormat("    {0}\n", file) |> ignore)
                sb.ToString()
            let options =
                let sb = new StringBuilder()
                this.OtherOptions |> Array.iter (fun op -> sb.AppendFormat("{0} ", op) |> ignore)
                sb.ToString()
            sprintf "OtherOptions(%s)\n  Files:\n%s  Options: %s" this.ProjectFileName files options


#endif